// This file is automatically generated.
use regex::Regex;
use std::str::Chars;

pub struct Lexer<'a> {
    src: Chars<'a>,
    location: Span,
    regexes: Vec<Regex>,
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct Span {
    line: usize,
    column: usize,
    offset: usize,
}

impl<'a> Lexer<'a> {
    pub fn current_location(&self) -> Span {
        self.location.clone()
    }

    fn eat(&mut self) {
        let c = self.src.next().unwrap();
        self.location.offset += 1;
        match c {
            '\n' => {
                self.location.column = 0;
                self.location.line += 1;
            },
            _ => self.location.column += 1,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Token {
    AbsEqual,
    LogicEqual,
    DivideEq,
    Divide,
    MinusEq,
    Minus,
    PlusEq,
    Plus,
    MultiplyEq,
    Multiply,
    OctNumber(String),
    HexNumber(String),
    DecNumber(String),
    Str(String),

    Unknown(char),
}

impl<'a> Lexer<'a> {
    pub fn new(src: &'a str) -> Self {
        let mut regexes = Vec::new();
        regexes.push(Regex::new(r#"^0o([0-7]+)"#).unwrap());
        regexes.push(Regex::new(r#"^0x([0-9A-Fa-f]+)"#).unwrap());
        regexes.push(Regex::new(r#"^([1-9]+[0-9]*)"#).unwrap());
        regexes.push(Regex::new(r#"^"((\\.|[^"])*)""#).unwrap());

        Lexer { src: src.chars(), location: Span { line: 0, column: 0, offset: 0 }, regexes }
    }
}

impl<'a> Iterator for Lexer<'a> {
    type Item = (Span, Token);

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let location = self.current_location();
            if self.src.as_str().starts_with(r#" "#) {
                self.eat();
            }
            else if self.src.as_str().starts_with(r#"==="#) {
                self.eat();
                self.eat();
                self.eat();
                return Some((location, Token::AbsEqual))
            }
            else if self.src.as_str().starts_with(r#"=="#) {
                self.eat();
                self.eat();
                return Some((location, Token::LogicEqual))
            }
            else if self.src.as_str().starts_with(r#"/="#) {
                self.eat();
                self.eat();
                return Some((location, Token::DivideEq))
            }
            else if self.src.as_str().starts_with(r#"/"#) {
                self.eat();
                return Some((location, Token::Divide))
            }
            else if self.src.as_str().starts_with(r#"-="#) {
                self.eat();
                self.eat();
                return Some((location, Token::MinusEq))
            }
            else if self.src.as_str().starts_with(r#"-"#) {
                self.eat();
                return Some((location, Token::Minus))
            }
            else if self.src.as_str().starts_with(r#"+="#) {
                self.eat();
                self.eat();
                return Some((location, Token::PlusEq))
            }
            else if self.src.as_str().starts_with(r#"+"#) {
                self.eat();
                return Some((location, Token::Plus))
            }
            else if self.src.as_str().starts_with(r#"*="#) {
                self.eat();
                self.eat();
                return Some((location, Token::MultiplyEq))
            }
            else if self.src.as_str().starts_with(r#"*"#) {
                self.eat();
                return Some((location, Token::Multiply))
            }
            else if self.regexes[0].is_match(self.src.as_str()) {
                let captured = self.regexes[0].captures(self.src.as_str()).unwrap();
                let matched = captured.get(0).unwrap();
                let result = captured.get(1).unwrap();
                for _ in 0..matched.as_str().len() {
                    self.eat();
                }
                return Some((location, Token::OctNumber(result.as_str().to_string())))
            }
            else if self.regexes[1].is_match(self.src.as_str()) {
                let captured = self.regexes[1].captures(self.src.as_str()).unwrap();
                let matched = captured.get(0).unwrap();
                let result = captured.get(1).unwrap();
                for _ in 0..matched.as_str().len() {
                    self.eat();
                }
                return Some((location, Token::HexNumber(result.as_str().to_string())))
            }
            else if self.regexes[2].is_match(self.src.as_str()) {
                let captured = self.regexes[2].captures(self.src.as_str()).unwrap();
                let matched = captured.get(0).unwrap();
                let result = captured.get(1).unwrap();
                for _ in 0..matched.as_str().len() {
                    self.eat();
                }
                return Some((location, Token::DecNumber(result.as_str().to_string())))
            }
            else if self.regexes[3].is_match(self.src.as_str()) {
                let captured = self.regexes[3].captures(self.src.as_str()).unwrap();
                let matched = captured.get(0).unwrap();
                let result = captured.get(1).unwrap();
                for _ in 0..matched.as_str().len() {
                    self.eat();
                }
                return Some((location, Token::Str(result.as_str().to_string())))
            }

            else {
                if self.src.as_str().is_empty() {
                    return None
                } else {
                    return Some((location, Token::Unknown(self.src.next().unwrap())))
                }
            }
        }
    }
}
